---
title: "R Notebook for Judge Wendy Li campaign project"
output: html_notebook
---

```{r}
library(tidyverse)
#library(censusxy)
library(tidycensus)
options(tigris_use_cache = TRUE)
library(tigris)
library(leaflet)
library(htmlwidgets) # use to export a leaflet map
library(sf)
library(wru)
library(hrbrthemes)

# install census api key. only need to run it once
#census_api_key("abcfd68dc76cdc9ebe18edd4361a760f6f513d0c", install = TRUE)

#voters
#install.packages("censusxy")
#remotes::install_github("slu-openGIS/censusxy")
```


load geocoded voter registeration file
```{r}
df = read_csv("Queens_voters_geocodio.csv")
df
str(df) # 1,190,287 × 50 
names(df)
missing_counts <- df %>%
  summarise(across(everything(), ~sum(is.na(.))))

print(missing_counts)

df %>%
  filter(county_emsid=="300090040")
```

download block level shape file for Queens county, note to use 2010 data to match census year 
2020 data is not being used b/c wru package does not supports 2020 census data
```{r}
ny_blocks = blocks(state = "NY", 
                   county = "Queens",
                   year = "2010")
?blocks
ny_blocks
find("blocks")

leaflet(ny_blocks) %>%
  addTiles() %>%
  addPolygons()


st_crs(ny_blocks)
class(ny_blocks)
plot(ny_blocks)
?blocks
```

turn dataframe into a sf (spatial frames) object. crs = 4269 cooresponds to Geodetic CRS: NAD83
which comes from the downloaded shape file. Note that this process also combines columns "Latitude"
and "Longitude" into new column called "geometry"
```{r}
df_NAD83 = st_as_sf(df,coords = c("Longitude","Latitude"), crs = 4269)
df_NAD83 #1,190,287 × 49
names(df_NAD83)

#?st_as_sf

df_NAD83 %>%
  filter(county_emsid=="300090040")
```

In this step, we are going to find the tract and block number for each address/row in the file
also during this process, we generated 2,146 additional rows from prior step. For the same county_emsid, it generates multiple block number based on slightly different geometry points. I don't understand why that happened but I decided to only keep the first occurrence and removing duplicates. This is to avoid the situation where later one the same county_emsid corresponds to multiple predicted races.
```{r}
df_sf_block <- st_join(df_NAD83, ny_blocks, join = st_within)
df_sf_block # 1,192,433 × 66 before removing duplicates

?st_join

df_sf_block %>%
  count(COUNTYFP10, name="UniqueNames")

df_sf_block %>%
  filter(duplicated(county_emsid))

df_sf_block %>%
  filter(county_emsid=="300090040")

# only keep the first occurrence and remove duplicates
df_sf_block = df_sf_block %>%
  distinct(county_emsid, .keep_all = TRUE)


df_sf_block #1,190,287 × 66. number of rows now matches the original dataset
```

Given that the dataset is big, I would like to create a subset to test functions
```{r}
# Set the seed for reproducibility
set.seed(100)

# Draw a stratified random sample of size 10 from each stratum
stratified_df_sf_block <- df_sf_block %>%
  sample_n(size=100)

# Display the stratified random sample
print(stratified_df_sf_block)
names(stratified_df_sf_block)
#stratified_df_sf_block %>%
  #count(county, name="UniqueNames")
```

downloaded both 2010 and 2020 Census data for NY state. 2010 is supported in wru package
```{r}
# Census for 2020
census_ny <- get_census_data(state = "NY",census.geo = "block",year = "2020") 
census_ny # don't overwirte this variable

# Census for 2010. Don't know if county can be specified in the query
census_ny_2010 <- get_census_data(states = c("NY"), census.geo = "block",year = "2010")

?get_census_data
census_ny_2010
```

create sub-set of data that is relevant for predict_race function
apply predict_race function
```{r}
df_sf_block_copy = df_sf_block
df_sf_block_copy = df_sf_block_copy %>%
  rename(county = COUNTYFP10,
         tract = TRACTCE10,
         block = BLOCKCE10) %>%
  select(county_emsid, surname, state, county, tract, block) %>%
  filter(!is.na(county))


# predict_race function won't run if state/county/tract/block columns have missing values
missing_counts <- df_sf_block_copy %>%
  summarise(across(everything(), ~sum(is.na(.))))
print(missing_counts)


View(df_sf_block_copy)


df_bisg = wru::predict_race(voter.file = df_sf_block_copy,
                            census.geo = "block",
                            census.data = census_ny_2010,
                            impute.missing = TRUE)

class(df_bisg)
df_bisg

```

create column race_est that has the maximum probability
```{r}
# Specify the columns for which you want to find the maximum
cols_to_check <- c("pred.whi", "pred.bla", "pred.his", "pred.asi", "pred.oth")

# Get the column index of the maximum value in each row across specified columns
max_col_index <- max.col(df_bisg[cols_to_check])
max_col_index

# Create a new column to flag which column contains the maximum value
df_bisg$max_prob_race <- cols_to_check[max_col_index]

# create column race_est
df_bisg = df_bisg %>%
  mutate(race_est = case_when(
    str_detect(max_prob_race, "\\.whi$") ~ "white",
    str_detect(max_prob_race, "\\.asi$") ~ "asian",
    str_detect(max_prob_race, "\\.his$") ~ "hispanic",
    str_detect(max_prob_race, "\\.bla$") ~ "black",
    str_detect(max_prob_race, "\\.oth$") ~ "other",
  ))

head(df_bisg, 10)
```

check if county_emsid corresponds to only 1 row in the dataset
```{r}
df_bisg %>%
  as.data.frame() %>%
  group_by(county_emsid) %>%
  summarise(num_races = n_distinct(race_est)) %>%
  filter(num_races > 1)
```

Create bar chart to show the race proportion in Queens
cross check this with the race predicted using zipWRUext2 package. results seem to be on par
```{r}
df_bisg %>%
  as.data.frame() %>%
  group_by(race_est) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = (cnt/sum(cnt))*100) %>%
  ggplot(aes(y=proportion, x=fct_reorder(race_est, proportion, .desc=TRUE))) +
  geom_bar(position="dodge", stat="identity", fill="skyblue") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), vjust = -0.5, color = "black", size = 3) +
  labs(title = "Race composition among registered voters in Queens New York", x = "race") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("viz/race_composition.png")
```
merge race_est column back to the main dataset
```{r}
df_bisg_race = df_bisg %>%
  select(county_emsid, race_est)

df_sf_block = left_join(df_sf_block, df_bisg_race, by = "county_emsid")

# replace all NA in race_est column with "other"

df_sf_block = df_sf_block %>%
  mutate(race_est = if_else(is.na(race_est), "other", race_est))

df_sf_block %>%
  count(race_est, name="UniqueNames")

```

Data cleanup and features engineering
Create is_Chinese column
```{r}
df_chinese = read_csv("common_surnames_chinese_background.csv")
#df_chinese

# %in% and join functions won't work if columns have whitespace 
df_sf_block = df_sf_block %>%
  mutate_at(vars(surname, first), trimws) %>% #remove whitespace
  mutate(is_Chinese = (surname %in% df_chinese$surname) & race_est=="asian")


df_sf_block %>% 
  as.data.frame() %>%
  group_by(is_Chinese, race_est) %>%
  summarise(cnt = n())

head(df_sf_block, 10)
```

remove white space for columns
Note: I probably don't need to create Number_Street column
```{r}
names(df_sf_block)
View(df_sf_block)

df_sf_block = df_sf_block %>%
  mutate_at(vars(email_address, telephone_optional, City), trimws) %>%
  mutate(email_address = ifelse(email_address == "", NA, email_address),
         telephone_optional = ifelse(telephone_optional == "", NA, telephone_optional),
         City = ifelse(City == "", NA, City)
         ) #%>%
  #filter(is.na(Email_Address))
  #count(Street_Name, name="UniqueNames")
```

create columns "age", "num_years_since_last_voted" and "party_full"
```{r}
# all calculated columns will have names all in lower cases
# Calculate "age"
df_sf_block <- df_sf_block %>%
  mutate(birthday = as.Date(birth_date, format = "%Y%m%d"),
         age = floor(time_length(interval(birthday, Sys.Date()), "years")),
         num_years_since_last_voted = 2023 - as.numeric(year_last_voted), # how many years ago the person voted
         party_full = case_when(
           political_party == "DEM" ~ "Democratic",
           political_party == "REP" ~ "Republican",
           political_party == "CON" ~ "Conservative",
           political_party == "WOR" ~ "Working Families",
           political_party == "BLK" ~ "No party affiliation",
           political_party == "GRE" ~ "Green",
           political_party == "LBT" ~ "Libertarian",
           political_party == "SAM" ~ "Serve America Movement",
           political_party == "IND" ~ "Independence",
           political_party == "WEP" ~ "Women’s Equality",
           political_party == "REF" ~ "Reform",
           TRUE ~ "No party affiliation")

  )


head(df_sf_block, 100)

```

Calculate "party_full" field when "other_party"=="OTH"
```{r}

pattern1 = "womens|womans" #78 counts - "Women’s Equality"
pattern2 = "green" #156 counts - "Green"
pattern3 = "independent|independence" #"Independence"
pattern4 = "working family|working families" #"Working Families"
pattern5 = "democratic|democrat|democrats" #"Democratic"
pattern6 = "^republican$" #"Republican"
pattern7 = "libertarian" #"Libertarian"

df_sf_block = df_sf_block %>%
  mutate_at(vars(other_party), trimws) %>% #remove whitespace in the column
  mutate(party_full = ifelse(political_party=="OTH", case_when(
           other_party == "DEM" ~ "Democratic",
           other_party == "REP" ~ "Republican",
           other_party == "CON" ~ "Conservative",
           other_party == "WOR" ~ "Working Families",
           other_party == "OTH" ~ "No party affiliation",
           other_party == "BLK" ~ "No party affiliation",
           other_party == "GRE" ~ "Green",
           other_party == "LBT" ~ "Libertarian",
           other_party == "SAM" ~ "Serve America Movement",
           other_party == "IND" ~ "Independence",
           other_party == "WEP" ~ "Women’s Equality",
           other_party == "REF" ~ "Reform",
           grepl(pattern1, other_party, ignore.case = TRUE) ~ "Women’s Equality",
           grepl(pattern2, other_party, ignore.case = TRUE) ~ "Green",
           grepl(pattern3, other_party, ignore.case = TRUE) ~ "Independence",
           grepl(pattern4, other_party, ignore.case = TRUE) ~ "Working Families",
           grepl(pattern5, other_party, ignore.case = TRUE) ~ "Democratic",
           grepl(pattern6, other_party, ignore.case = TRUE) ~ "Republican",
           grepl(pattern7, other_party, ignore.case = TRUE) ~ "Libertarian",
           TRUE ~ "No party affiliation"), party_full))

# create bar chart on party proportion in Queens
df_sf_block %>%
  as.data.frame() %>%
  group_by(party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(y=proportion, x=fct_reorder(party_full, proportion, .desc=TRUE))) +
  geom_bar(position="dodge", stat="identity", fill="lightgreen") +
  geom_text(aes(label = paste0(round(proportion,2), "%")), vjust = -0.5, color = "black", size = 3) +
  labs(title = "Party composition among registered voters in Queens New York", x = "party") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(color = "black"),
        axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("viz/party_composition.png")
```

create a subset of data to facilitate analysis done in the voting history table
```{r}
#names(df_sf_block)

df_sf_block %>%
  as.data.frame() %>%
  select(county_emsid, gender, race_est) %>%
  write.csv(file = "voters_gender_race.csv", row.names = FALSE)

```



load the processed data from voting history records
```{r}
df_voting_hist = read_csv("voting_history_processed.csv")
df_voting_hist
```

Merge voter registeration with voting history records
```{r}
df_sf_block = df_sf_block %>%
  left_join(df_voting_hist, by = "county_emsid") %>%
  mutate_at(vars(Total_times_voted, Total_times_voted_Primary, 
                 Total_times_voted_General, Last4yr_times_voted_primary,
                 Last4yr_times_voted_general, Last4yr_times_voted), ~ replace(., is.na(.), 0)) %>%
  mutate(voted_ = ifelse(Total_times_voted>0, "Y", "N"),
         voted_Primary = ifelse(Total_times_voted_Primary>0, "Y", "N"),
         voted_General = ifelse(Total_times_voted_General>0, "Y", "N"),
         voted_Last4yr = ifelse(Last4yr_times_voted>0, "Y", "N"),
         voted_Primary_Last4yr = ifelse(Last4yr_times_voted_primary>0, "Y", "N"),
         voted_General_Last4yr = ifelse(Last4yr_times_voted_general>0, "Y", "N"),
         telephone_ = ifelse(is.na(telephone_optional), "N","Y"),
         email_ = ifelse(is.na(email_address), "N","Y")
         )


```


merge main dataset from prior step with Latitude and Longitude columns from the original df and save down all the data points as a csv file
```{r}
df_lat_long = df %>%
  select(county_emsid, Latitude, Longitude)


df_sf_block = df_sf_block %>%
  left_join(df_lat_long, by = "county_emsid")

df_sf_block %>%
  write.csv(file = "voter_registration_full.csv", row.names = FALSE)

View(df_sf_block)
```




Below section is dedicated to the specific campaign asks:
1. Create list of Chinese & Non-Democratic voters with non-blank Email_Address
Number of observations: 16,191
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE
         & !party_full=="Democratic"
         & email_=="Y") %>%
  select(surname, first, middle, email_address)

```

campaign asks #2
Create list of Chinese & Non-Democratic voters with non-blank Telephone
Number of observations: 21,446
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE
         & !party_full=="Democratic"
         & telephone_=="Y") %>%
  select(surname, first, middle, telephone_optional)

```

campaign asks #3
create the list of top 50 buildings in Queens. Please seperate the voter list by building. You can send the building list with voters in one email or send 50 emails. the list should include name, address, registered as Democrat, phone number, email address, the years voted from 2021 to 2023

locate the top ranked buildings
Note: initial I used column Number_Street to do the groupby but later noticed that that column has some missing values. This column is a combination of Number column and Street column and both columns are produced by Geocodio. To avoid the situation where NA gets counted as a group, I ended up using address as the groupby factor in the end.

I was asked to extract the list for certain building so below code chunk is for that task
I need to create a UI tool so they can search themselves
```{r}
# find the exact value for the address column
df_sf_block %>%
  as.data.frame() %>%
  filter(zip_code==11354 & grepl("^131-", address) & party_full == "Democratic") %>%
  count(address, name="UniqueNames")

# find the exact rank_
df_output = df_sf_block %>%
  as.data.frame() %>%
  filter(party_full == party_selected) %>%
  group_by(address) %>%
  summarise(cnt_dem = n()) %>%
  arrange(desc(cnt_dem)) %>%
  mutate(rank_ = rank(-cnt_dem, ties.method = "min")) %>%
  left_join(cols_required, by="address") %>% 
  left_join(df_voter_history_pri21to23, by = "county_emsid") %>%
  mutate(across(all_of(c("primary_2022", "primary_2021", "primary_2023")), ~ifelse(is.na(.), 0, .)),
         floor_num = as.integer(str_extract(apartment_number, "\\d+"))) %>%
  filter(address %in% c("131-01 40th ROAD, QUEENS, NY, 11354, USA",
                        "131-03 40th ROAD, QUEENS, NY, 11354, USA")) %>%
  arrange(rank_, address, floor_num, apartment_number)

# Split the data frame based on "address"
building_list <- split(df_output, df_output$address)

# create the output folder
destination_path = paste0("address_ad_hoc")
dir.create(destination_path, showWarnings = FALSE)
#destination_path

# Save each individual data frame as a CSV file
lapply(names(building_list), function(building) {
  building_rank = unique(building_list[[building]]$rank_)[1]
  file_name = paste0("address_ad_hoc/", "Rank", building_rank, "_" , building, ".csv")
  # sort the data in each building by floor number then apartment number
  # building_list[[building]] = building_list[[building]][order(building_list[[building]]$floor_num,
  #                                                             building_list[[building]]$apartment_number), ]
  # move the floor_num column before the apartment_number column to the beginning
  building_list[[building]] = building_list[[building]][, c("floor_num", "apartment_number", setdiff(names(building_list[[building]]), c("floor_num", "apartment_number")))]
  write.csv(building_list[[building]], file = file_name, row.names = FALSE)
})
```

User feedback: the campaign manager asked if the data in each building could be sorted by floor number so I created this column floor_num to extract the floor number out of apartment_number column. Note apartment_number column is not clean, you see apartment number as 1A or 6G or APT 4E.
```{r}
# load csv that has information on past primary elections
df_voter_history_pri21to23 = read_csv("voting_history_primarycount21to23.csv")

# select fields that are being asked to be included in the voters list
cols_required = df_sf_block %>%
  as.data.frame() %>%
  filter(party_full == party_selected) %>%
  select(county_emsid, surname, first, middle, address, apartment_number,
         gender, age, party_full, telephone_optional,email_address)

# user inputs
start_pt = 1949 # starting rank number
end_pt = 1949 # ending rank number
party_selected = "Democratic"


# create ranked address list determined by the number of democrats
df_output = df_sf_block %>%
  as.data.frame() %>%
  filter(party_full == party_selected) %>%
  group_by(address) %>%
  summarise(cnt_dem = n()) %>%
  #top_n(50, wt = cnt_dem) %>%
  arrange(desc(cnt_dem)) %>%
  mutate(rank_ = rank(-cnt_dem, ties.method = "min")) %>% # Gives the smallest rank to tied values
  #filter(address=="144-44 38th AVENUE, QUEENS, NY, 11354, USA")
  #write.csv(file = "ranked_address.csv", row.names = FALSE) # list to be sent to teammate Rui who does the map
  left_join(cols_required, by="address") %>% 
  left_join(df_voter_history_pri21to23, by = "county_emsid") %>%
  mutate(across(all_of(c("primary_2022", "primary_2021", "primary_2023")), ~ifelse(is.na(.), 0, .)),
         floor_num = as.integer(str_extract(apartment_number, "\\d+"))) %>%
  #str() #743,958 matches total democrats in the df_sf_block
  filter(rank_ >= start_pt & rank_ <= end_pt)
  
df_output
# Split the data frame based on "address"
building_list <- split(df_output, df_output$address)

# create the output folder
destination_path = paste0(start_pt, "_to_", end_pt, "_", party_selected)
dir.create(destination_path, showWarnings = FALSE)
#destination_path

# Save each individual data frame as a CSV file
lapply(names(building_list), function(building) {
  building_rank = unique(building_list[[building]]$rank_)[1]
  file_name = paste0(destination_path, "/", "Rank", building_rank, "_" , building, ".csv")
  # sort the data in each building by floor number then apartment number
  building_list[[building]] = building_list[[building]][order(building_list[[building]]$floor_num,
                                                              building_list[[building]]$apartment_number), ]
  # move the floor_num column before the apartment_number column to the beginning
  building_list[[building]] = building_list[[building]][, c("floor_num", "apartment_number", setdiff(names(building_list[[building]]), c("floor_num", "apartment_number")))]
  write.csv(building_list[[building]], file = file_name, row.names = FALSE)
})
```
campaign ask: flagging PRIME voters (defined by the DEM voters who have voted three times in the past three years' DEM primaries)
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(party_full == "Democratic") %>%
  group_by(address) %>%
  summarise(cnt_dem = n()) %>%
  arrange(desc(cnt_dem)) %>%
  mutate(rank_ = rank(-cnt_dem, ties.method = "min")) %>%
  left_join(cols_required, by="address") %>% 
  left_join(df_voter_history_pri21to23, by = "county_emsid") %>%
  mutate(across(all_of(c("primary_2022", "primary_2021", "primary_2023")), ~ifelse(is.na(.), 0, .)),
         floor_num = as.integer(str_extract(apartment_number, "\\d+")),
         past3yr_primary_total = primary_2021 + primary_2022 + primary_2023) %>%
  filter(past3yr_primary_total>=3) #48,613 PRIME voters
```



Below section is dedicated to testing the logistic modeling. First, we are going to check the proportion of the below. The assumption here is that if we can't locate a voting record for a voter, we are going to assume that voter has never voted.

1. % of registered voters who voted - 19.4% of the registered voter never voted vs 80.6% of the voter who voted at least once
2. % of voters who voted also voted in the Primaries among everyone who voted - 51.6% of the voters who voted also voted in the Primaries. looks like this is a balance dataset which made me wondering if I could run a logistic model to see what kinds of people are habitual vs. episodic voters.
Interesting study on this:
https://www.pewresearch.org/politics/2017/09/14/how-drop-off-voters-differ-from-consistent-voters-and-non-voters/
```{r}
df_sf_block %>%
  as.data.frame() %>%
  group_by(voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = (cnt/sum(cnt))*100) %>%
  ggplot(aes(y=proportion, x=voted_)) +
  geom_bar(position="dodge", stat="identity", fill="skyblue") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), vjust = 0, color = "black", size = 3) +
  labs(title = "Voter turnout %",x = "voted?")


df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y") %>%
  group_by(voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = (cnt/sum(cnt))*100) %>%
  ggplot(aes(y=proportion, x=voted_Primary)) +
  geom_bar(position="dodge", stat="identity", fill="skyblue") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), vjust = 0, color = "black", size = 3) +
  labs(title = "Voters who voted in primary elections %",x = "voted primaries")


```

creating subset of data for logistic modeling - decided not to go down that route in this project
```{r}

df_voted = df_sf_block %>%
  as.data.frame() %>%
  filter(voted_ == "Y") %>%
  select(gender, age, race_est, party_full, num_years_since_last_voted,
         telephone_, email_, voted_Primary)
  
```

data prepping before fitting to a logistic model
```{r}
columns_factor = c("gender", "race_est", "party_full", "telephone_", "email_", "voted_Primary")
df_voted[columns_factor] = lapply(df_voted[columns_factor], as.factor)
str(df_voted)
```
use xtabs() function to make contingency tables of response to check if the data were unbalanced
we are going to check our dependent variable against each of the categorical independent variable
```{r}
xtabs(~ voted_Primary + gender, data=df_voted)
```

```{r}
xtabs(~ voted_Primary + race_est, data=df_voted)
```

```{r}
xtabs(~ voted_Primary + party_full, data=df_voted)
```

```{r}
xtabs(~ voted_Primary + telephone_, data=df_voted)
```

```{r}
xtabs(~ voted_Primary + email_, data=df_voted)
```

it looks like if we cut down the number of predictors, it does not help with the performance of the model
```{r}
logistic = glm(voted_Primary ~ ., data=df_voted, family="binomial")
summary(logistic)

logistic.justage = glm(voted_Primary ~ age + gender + race_est, data=df_voted, family="binomial")
summary(logistic.justage)
```

calculate Pseudo R square. 25.9% looks really bad
```{r}
ll.null = logistic$null.deviance/-2
ll.proposed = logistic$deviance/-2
(ll.null - ll.proposed) / ll.null
```


Below section is dedicated to the EDA of this project
Create Age Box plot for voters in Queens by party
```{r}
# outliers in the dataset
# df_sf_block %>%
#   as.data.frame() %>%
#   filter(age > 100)

df_sf_block %>%
  as.data.frame() %>%
  ggplot(aes(x = fct_reorder(party_full, age, .desc=TRUE), y = age, fill=party_full)) +
  geom_boxplot() +
  #facet_wrap(~gender) +
  coord_flip() +
  theme_classic() +
  labs(title = "Age box plot by party", x = "party") +
  theme(legend.position="none")

ggsave("viz/age box plot by party.png")
```

Create Age Box plot for Chinese American voters in Queens by party
do I reallly need this plot?
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE) %>%
  ggplot(aes(x = fct_reorder(party_full, age, .desc=TRUE), y = age, fill=party_full)) +
  geom_boxplot() +
  coord_flip() +
  theme_classic() +
  labs(title = "Age box plot among Chinese American by party", x = "party") +
  theme(legend.position="none")

#ggsave("viz/age box plot by party_Chinese.png")
```


Create Age Box plot for voters in Queens by race
```{r}
df_sf_block %>%
  as.data.frame() %>%
  ggplot(aes(x = fct_reorder(race_est, age, .desc=TRUE), y = age, fill=race_est)) +
  geom_boxplot() +
  coord_flip() +
  theme_classic() +
  labs(title = "Age box plot by race", x = "race") +
  theme(legend.position="none")

ggsave("viz/age box plot by race.png")
```


Age
Create Age Histogram for voters under age of 100 in Queens
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(age < 100 & party_full %in% c("Republican", "Democratic", "No party affiliation")) %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 5, fill="#69b3a2", color="#e9ecef", alpha=1.0) +
  ggtitle("Bin size = 5") +
  facet_wrap(~party_full) +
  theme_bw() +
  labs(title = "Age Histogram for voters under age of 100 in Queens")


```

Create Age Histogram for Chinese voters under age of 100 in Queens
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(age < 100 
         &is_Chinese==TRUE 
         &party_full %in% c("Republican", "Democratic", "No party affiliation")) %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 5, fill="#69b3a2", color="#e9ecef", alpha=1.0) +
  ggtitle("Bin size = 5") +
  facet_wrap(~party_full) +
  theme_bw() +
  labs(title = "Age Histogram for Chinese voters under age of 100 in Queens")

```


explore the correlation between age and total number of times voted
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y") %>%
  select(age, Total_times_voted) %>%
  ggplot(aes(x=age, y=Total_times_voted)) +
  geom_point() +
  geom_smooth(method=lm , color="red", se=FALSE) +
  theme_classic()
  
```


Create bar chart to show party % for each race in Queens
We will focus on three major parties
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(party_full %in% c("Democratic", "Republican", "No party affiliation")) %>%
  group_by(race_est, party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=party_full, y=proportion, x=race_est)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.0, color = "black", size = 3) +
  labs(title = "Party composition by race in Queens New York", x = "race", fill = "party") +
  theme_classic()
  
ggsave("viz/party composition by race.png")
```


Create bar chart to show party % by gender in Queens
We will focus on three major parties
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(party_full %in% c("Democratic", "Republican", "No party affiliation") & gender %in% c("F","M")) %>%
  group_by(gender, party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=party_full, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.0, color = "black", size = 3) +
  labs(title = "Party composition by gender in Queens New York", x = "gender", fill = "party") +
  theme_classic()
  
ggsave("viz/party composition by gender.png")
```


Create bar chart to show party % by gender in Queens
We will focus on three major parties
race = Chinese American
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE 
         & party_full %in% c("Democratic", "Republican", "No party affiliation") 
         & gender %in% c("F","M")) %>%
  group_by(gender, party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=party_full, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.0, color = "black", size = 3) +
  labs(title = "Party composition by gender in Queens New York", 
       subtitle = "race = Chinese American", x = "gender", fill = "party") +
  theme_classic()
  
ggsave("viz/party composition by gender_Chinese.png")
```






Create bar chart to show party % for each race in Queens for Chinese
We will focus on three major parties and compare results between Chinese vs non-Chinese Asians
Insight: Chinese is not prone to be a Republican compared to other Asians. They have higher % in the
"no party" category.
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(race_est=="asian" & party_full %in% c("Democratic", "Republican", "No party affiliation")) %>%
  group_by(is_Chinese, party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=party_full, y=proportion, x=is_Chinese)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.0, color = "black", size = 3) +
  labs(title = "Party composition among Asians in Queens New York", x = "Chinese American?", fill = "party") +
  theme_classic()
  
ggsave("viz/party composition Chinese vs non Chinese.png")
```


Create bar chart to show party % per race for voters who voted in the Primary Election in Queens
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(Total_times_voted_Primary>0) %>%
  group_by(race_est, party_full) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)) %>%
  ggplot(aes(fill=party_full, y=proportion, x=race_est)) +
  geom_bar(position="dodge", stat="identity") +
  labs(title = "Political party % per race for voters who voted in the Primary Election in Queens",
       x = "race",
       fill = "political party")

```


Create Age Histogram for Asian Republican voters under age of 100 in Queens
Insight: Chinese Republicans tends to be a bit older than non-Chinese Asian Republicans
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(age < 100 & race_est=="asian" & party_full=="Republican") %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 5, fill="#69b3a2", color="#e9ecef", alpha=1.0) +
  ggtitle("Bin size = 5") +
  facet_wrap(~is_Chinese) +
  theme_bw() +
  labs(title = "Age Histogram for Asian Republican under age of 100 in Queens")

```


Create Age Box plot for Chinese Republican voters under age of 100 in Queens
Insight: The box plot below proves that Chinese Republicans tends to be a bit older than non-Chinese Asian Republicans
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(age < 100 & race_est=="asian" & party_full=="Republican") %>%
  ggplot(aes(party_full, age, fill=party_full)) +
  geom_boxplot() +
  facet_wrap(~is_Chinese) +
  #coord_flip() +
  theme_bw() +
  labs(title = "Age Box plot for Chinese Republican vs Non-Chinese Republican under age of 100 in Queens",
       x = "political party")
```



```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y") %>%
  ggplot(aes(Total_times_voted)) +
  geom_histogram(binwidth = 1, fill="#69b3a2", color="#e9ecef", alpha=1.0) +
  #scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  ggtitle("Bin size = 1") +
  #facet_wrap(~party_full) +
  theme_classic() +
  labs(title = "Last4yr total times voted in general elections histogram",
       y = "count")

```


```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y") %>%
  ggplot(aes(Total_times_voted)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=1.0) +
  #scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  #ggtitle("Bin size = 5") +
  #facet_wrap(~party_full) +
  theme_classic() +
  labs(title = "Last4yr total times voted in general elections density plot")
```



Subject: gender in voter turnout
gender overview
```{r}
df_sf_block %>%
  as.data.frame() %>%
  group_by(gender) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=gender, y=proportion, x=fct_reorder(gender, proportion, .desc=TRUE))) +
  geom_bar(position="dodge", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,2), "%")), vjust = -0.5, color = "black", size = 3) +
  theme_bw() +
  labs(title = "Gender composition among registered voters in Queens New York") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(color = "black"))
        #axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("viz/gender_composition.png")
```


Which gender has higher percentage to vote after voter registration?
Insight: Female
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(gender %in% c("F", "M")) %>%
  group_by(gender, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which gender has higher percentage to vote after voter registration?",
       fill = "voted?")

ggsave("viz/turnout by gender.png")
```

Which gender has higher percentage to vote among Chinese American after voter registration?
Insight: Female
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE & gender %in% c("F", "M")) %>%
  group_by(gender, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which gender has higher percentage to vote after voter registration?",
       subtitle = "race = Chinese American",
       fill = "voted?")

ggsave("viz/turnout by gender_Chinese.png")
```


Now we are going to control gender factor, and see how race plays a role in voter turnout
gender = F
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(gender =="F") %>%
  group_by(race_est, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=race_est)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote after voter registration?",
       subtitle = "gender = F",
       x = "race", fill = "voted?")

ggsave("viz/turnout by race_genderF.png")
```


Now we are going to control gender factor, and see how race plays a role in voter turnout
gender = F
race = asian
Insight: Chinese American has lower participating rate compared to non-Chinese American Asians
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(gender =="F" & race_est=="asian") %>%
  group_by(is_Chinese, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=is_Chinese)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote after voter registration?",
       subtitle = "gender = F & race = asian",
       x = "Chinese American?", fill = "voted?")

ggsave("viz/turnout by race_genderF_Chinese vs non Chinese.png")
```



Now we are going to control gender factor, and see how race plays a role in voter turnout
gender = M
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(gender =="M") %>%
  group_by(race_est, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=race_est)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote after voter registration?",
       subtitle = "gender = M",
       x = "race", fill = "voted?")

ggsave("viz/turnout by race_genderM.png")
```


Now we are going to control gender factor, and see how race plays a role in voter turnout
gender = M
race = asian
Insight: Chinese American has lower participating rate compared to non-Chinese American Asians
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(gender =="M" & race_est=="asian") %>%
  group_by(is_Chinese, voted_) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_, y=proportion, x=is_Chinese)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote after voter registration?",
       subtitle = "gender = M & race = asian",
       x = "Chinese American?", fill = "voted?")

ggsave("viz/turnout by race_genderM_Chinese vs non Chinese.png")
```




Subject: gender in Habitual vs Episodic voters
Which gender has higher percentage to vote in the primary elections?
Insight: Female
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y" & gender %in% c("F", "M")) %>%
  group_by(gender, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which gender has higher percentage to vote in the primary elections?",
       fill = "voted in primary?")

ggsave("viz/primary turnout by gender.png")
```

Subject: gender in Habitual vs Episodic voters
Which gender has higher percentage to vote among Chinese American in the primary elections?
Insight: Female
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(is_Chinese==TRUE & voted_=="Y" & gender %in% c("F", "M")) %>%
  group_by(gender, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=gender)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which gender has higher percentage to vote in the primary elections?",
       subtitle = "race = Chinese American",
       fill = "voted in primary?")

ggsave("viz/primary turnout by gender_Chinese.png")
```




Now we are going to control gender factor, and see how race plays a role in voter turnout in primary elections
gender = F
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y" & gender=="F") %>%
  group_by(race_est, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=race_est)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote in the primary elections?",
       subtitle = "gender = F", x = "race", fill = "voted in primary?")

ggsave("viz/primary turnout by race_genderF.png")
```
Now we are going to control gender factor, and see how race plays a role in voter turnout in primary elections
gender = F
race = asian
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y" & gender=="F" & race_est=="asian") %>%
  group_by(is_Chinese, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=is_Chinese)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote in the primary elections?",
       subtitle = "gender = F & race = asian", x = "Chinese American?", fill = "voted in primary?")

ggsave("viz/primary turnout by race_genderF_Chinese vs non Chinese.png")
```



Now we are going to control gender factor, and see how race plays a role in voter turnout in primary elections
gender = M
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y" & gender=="M") %>%
  group_by(race_est, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=race_est)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote in the primary elections?",
       subtitle = "gender = M", x = "race", fill = "voted in primary?")

ggsave("viz/primary turnout by race_genderM.png")
```

Now we are going to control gender factor, and see how race plays a role in voter turnout in primary elections
gender = M
race = asian
```{r}
df_sf_block %>%
  as.data.frame() %>%
  filter(voted_=="Y" & gender=="M" & race_est=="asian") %>%
  group_by(is_Chinese, voted_Primary) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt)*100) %>%
  ggplot(aes(fill=voted_Primary, y=proportion, x=is_Chinese)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label = paste0(round(proportion,1), "%")), position = "stack", vjust = 1.5, color = "black", size = 3) +
  theme_classic() +
  labs(title = "Which race has higher percentage to vote in the primary elections?",
       subtitle = "gender = M & race = asian", x = "Chinese American?", fill = "voted in primary?")

ggsave("viz/primary turnout by race_genderM_Chinese vs non Chinese.png")
```





Shiny ideas:
Create dynamic bar charts showing the top n City with most its voters for a political party in Queens
```{r}
# select top X city you would like to see in the dataset

n = 10
select_party = "Democratic"

party_cnt_City = as.data.frame(
  df_sf_block %>%
    as.data.frame() %>%
    filter(party_full == select_party) %>%
    group_by(City) %>%
    summarise(cnt = n()) %>%
    mutate(proportion = cnt/sum(cnt)*100) %>%
    #top_n(n, wt = cnt) %>%
    arrange(desc(cnt)) %>%
    mutate(cumulative_sum = cumsum(cnt),
           cumulative_sum_percent = cumsum(proportion))
  
)

party_cnt_City

print(paste("Percentage of voters covered is", round(sum(party_cnt_City$proportion)),"%"))

# the plot won't be effective if no number of top City is selected
party_cnt_City %>%
  ggplot(aes(x=fct_reorder(City,cnt, .desc=TRUE), y=cnt, fill=City)) +
  geom_bar(position="dodge", stat="identity") +
  
  geom_text(aes(label = cnt), vjust = -0.5, size = 2.4,
            position = position_dodge(width = 0.3)) +
  labs(title = sprintf("Top %d City with most %s voters in Queens", n, select_party), y = "count") +
  scale_fill_brewer(palette="Spectral") +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 0.5, size=7))

```


Create dynamic bar charts showing the top n Street in certain City for a given political party
```{r}
# select top X street and City you would like to see in the dataset

n = 10
select_party = "Democratic"
select_city ="Forest Hills"


party_cnt_Street = as.data.frame(
  df_sf_block %>%
    as.data.frame() %>%
    filter(party_full == select_party & City == select_city) %>%
    group_by(Number_Street) %>%
    summarise(cnt = n()) %>%
    mutate(proportion = cnt/sum(cnt)) %>%
    top_n(10, wt = cnt) %>%
    arrange(desc(cnt)) 

)

party_cnt_Street

party_cnt_Street %>%
  ggplot(aes(x=fct_reorder(Number_Street,cnt, .desc=TRUE), y=cnt, fill=Number_Street)) +
  geom_bar(position="dodge", stat="identity") +
  geom_text(aes(label = cnt), vjust = -0.5, size = 2.4,
            position = position_dodge(width = 0.3)) +
  labs(title = sprintf("Top %d buildings with most %s voters in %s", n, select_party, select_city), y = "count") +
  scale_fill_brewer(palette="Spectral") +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1.0, size=7))


```

```{r}
n = 10
select_party = "Democratic"
select_city ="Forest Hills"


party_cnt_Street_test = as.data.frame(
  df_sf_block %>%
    as.data.frame() %>%
    filter(party_full == select_party & City == select_city) %>%
    group_by(Number_Street, as.factor(Latitude), as.factor(Longitude)) %>%
    summarise(cnt = n()) %>%
    mutate(proportion = cnt/sum(cnt)) %>%
    top_n(10, wt = cnt) %>%
    arrange(desc(cnt))

)

party_cnt_Street_test

```



The use case here is if the campaign wants to target n number of voters, how many buildings do they need to visit.
```{r}
#View(df_sf_block)
df_building = df_sf_block %>%
    as.data.frame() %>%
    filter(party_full == "Democratic") %>%
    group_by(address, Longitude, Latitude) %>%
    summarise(cnt_dem = n()) %>%
    arrange(desc(cnt_dem))
    #mutate(rank_ = rank(-cnt_dem, ties.method = "min"))

#df_building
find_buildings <- function(df, n) {
  # Calculate the cumulative sum of residents in descending order
  cumulative_sum <- cumsum(df$cnt_dem)
  
  # Find the index where cumulative sum exceeds or equals 'n'
  index <- which.max(cumulative_sum >= n)
  
  # Extract the building addresses up to the index
  buildings <- df[1:index, ]
  
  return(buildings)
}

df_map = find_buildings(df_building, 1000)
df_map


```


this might work in the Shiny app?
the campaign does not need this. They know the magic number is 200,000 already. 
```{r}
df_lat_long_unique = df_sf_block %>%
  as.data.frame() %>%
  select(address, Latitude, Longitude) %>%
  distinct()


df_building = df_sf_block %>%
    as.data.frame() %>%
    filter(party_full == "Democratic") %>%
    group_by(address) %>%
    summarise(cnt_dem = n()) %>%
    arrange(desc(cnt_dem)) %>%
    mutate(rank_ = rank(-cnt_dem, ties.method = "min"),
           cumulative_sum = cumsum(cnt_dem),
           cumulative_percent = cumulative_sum/ sum(df_building$cnt_dem)) %>%
    left_join(df_lat_long_unique, by="address") #%>%
    #write.csv(file = "address_long_lat_rank_cnt.csv", row.names = FALSE)

sum(df_building$cnt_dem) #743958
view(df_building)

# Initialize an empty data frame to store the result
result_df <- data.frame(address = character(), cnt_dem = numeric(), rank_ = numeric(), 
                        cumulative_sum = numeric(), cumulative_percent = numeric(),
                        Latitude = numeric(), Longitude = numeric())

# Initialize variables
#result <- character(0)
cumulative_count <- 0
target <- 200000

# Iterate through the rows and add buildings until the target is reached
for (i in 1:nrow(df_building)) {
  if (cumulative_count + df_building$cnt_dem[i] <= target) {
    #result <- c(result, df_building$address[i], df_building$rank_[i], df_building$cnt_dem[i])
    result_df <- rbind(result_df, df_building[i, ])
    cumulative_count <- cumulative_count + df_building$cnt_dem[i]
  } else {
    break
  }
}

# Print the list of buildings
View(result_df)
result_df

m = leaflet(data=result_df) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=~Longitude, lat=~Latitude, popup= ~as.character(address), label=~as.character(rank_))


saveWidget(m, file = "interactive_map.html")
```


create a query tool?
```{r}
# select fields that are being asked to be included in the voters list
df_sf_block %>%
  as.data.frame() %>%
  count(neighborhood, name="UniqueNames")
  filter(party_full == "Democratic") %>%
  filter(grepl("65th crescent", address, ignore.case=TRUE))

query_table = df_sf_block %>%
  as.data.frame() %>%
  filter(party_full == "Democratic") %>%
  select(county_emsid, surname, first, middle, gender, age,
         address, apartment_number, City, zip_code, telephone_optional, email_address) %>%
  left_join(df_voter_history_pri21to23, by = "county_emsid") %>%
  mutate(across(all_of(c("primary_2022", "primary_2021", "primary_2023")), ~ifelse(is.na(.), 0, .)),
         floor_num = as.integer(str_extract(apartment_number, "\\d+")))
```





exploring creating density maps - nothing works
```{r}

df_dem_percent = df_sf_block %>%
  as.data.frame() %>% # we want to remove the sticky geometry using as.data.frame
  filter(party_full == "Democratic") %>%
  group_by(TRACTCE10) %>%
  summarise(total_dem_tract = n())

#class(df_dem_percent)

# we need to use this step in order to regain our region geometries so that we can make some maps
df_dem_percent_sf = left_join(df_sf_block, df_dem_percent)

class(df_dem_percent_sf)
plot(df_dem_percent_sf['total_dem_tract'])

```

```{r}
ggplot(df_dem_percent_sf) +
  geom_sf(aes(fill = total_dem_block)) +
  theme_bw() +
  labs(fill = "Total Democrats per block") +
  scale_fill_continuous(low = "khaki", high =  "firebrick") #labels = total_dem_block)

```



```{r}
ny_income <- get_acs(
  geography = "tract", 
  variables = "B19013_001",
  state = "NY", 
  year = 2020,
  geometry = TRUE
)

ny_income

plot(ny_income["estimate"])
```

didnt't work
```{r}
library(tmap)
df_dem_percent = df_sf_block %>%
  filter(party_full == "Democratic") %>%
  group_by(TRACTCE10) %>%
  summarise(cnt = n()) %>%
  mutate(proportion = cnt/sum(cnt))

df_dem_percent

tm_shape(df_dem_percent) +
  tm_polygons(col = "proportion")
```



